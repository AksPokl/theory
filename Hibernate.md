Session — это основной интерфейс, который отвечает за связь с базой данных. Так же, он помогает создавать объекты запросов для получение
персистентных объектов.
Обьект Session можно получить из SessionFactory :
Session session = sessionFactory.openSession();
Роль интерфейса Session:

- является оберткой для jdbc подключения к базе данных; 
- является фабрикой для транзакций
- является хранителем обязательного кэша первого уровня.
Объект Hibernate Session не является потокобезопасным. Каждый поток должен иметь свой собственный объект Session и закрывать его по окончанию.

На все приложение существует только одна SessionFactory и она инициализируеться вместе со стартом приложения. 
SessionFactory кэширует мета-дату и SQL запросы которые часто используются приложением во время работы.
Так же оно кэширует информацию которая была получена в одной из транзакций и может быть использована и в других транзакциях.
Т.к. объект SessionFactory immutable (неизменяемый), он потокобезопасный. Множество потоков может обращаться к одному объекту одновременно.

oбъект-сущность может находиться в одном из 3-х состояний (статусов):

- transient object. Объекты в данном статусе — это заполненные экземпляры классов-сущностей. Могут быть сохранены в БД. Не присоединены к сессии. Поле Id не должно быть заполнено, иначе объект имеет статус detached ;
- persistent object. Объект в данном статусе — так называемая хранимая сущность, которая присоединена к конкретной сессии. Только в этом статусе объект взаимодействует с базой данных. При работе с объектом данного типа в рамках транзакции все изменения объекта записываются в базу;
- detached object. Объект в данном статусе — это объект, отсоединённый от сессии, может существовать или не существовать в БД.

get() и load().
- get() загружает данные сразу при вызове, в то время как load() использует прокси объект и загружает данные только тогда, когда это требуется на самом деле. В этом плане load() имеет преимущество в плане ленивой загрузки данных.
- load() бросает исключение, когда данные не найдены. Поэтому его нужно использовать только при уверенности в существовании данных.
- Нужно использовать метод get(), если необходимо удостовериться в наличии данных в БД.

Транзакции:
- Propagation.REQUIRED — выполняться в существующей транзакции, если она есть, иначе создавать новую.
- Propagation.MANDATORY — выполняться в существующей транзакции, если она есть, иначе генерировать исключение.
- Propagation.SUPPORTS — выполняться в существующей транзакции, если она есть, иначе выполняться вне транзакции.
- Propagation.NOT_SUPPORTED — всегда выполняться вне транзакции. Если есть существующая, то она будет остановлена.
- Propagation.REQUIRES_NEW — всегда выполняться в новой независимой транзакции. Если есть существующая, то она будет остановлена до окончания выполнения новой транзакции.
- Propagation.NESTED — если есть текущая транзакция, выполняться в новой, так называемой, вложенной транзакции. Если вложенная транзакция будет отменена, то это не повлияет на внешнюю транзакцию; если будет отменена внешняя транзакция, то будет отменена и вложенная. Если текущей транзакции нет, то просто создаётся новая.
- Propagation.NEVER — всегда выполнять вне транзакции, при наличии существующей генерировать исключение.

Требования JPA к Entity:
- Entity класс должен быть отмечен аннотацией Entity или описан в XML файле конфигурации JPA,
- Entity класс должен содержать public или protected конструктор без аргументов (он также может иметь конструкторы с аргументами), 
- Entity класс должен быть классом верхнего уровня (top-level class),
- Entity класс не может быть enum или интерфейсом,
- Entity класс не может быть финальным классом (final class), 
- Entity класс не может содержать финальные поля или методы, если они участвуют в маппинге (persistent final methods or persistent final instance variables),
- Если объект Entity класса будет передаваться по значению как отдельный объект (detached object), например через удаленный интерфейс (through a remote interface), он так же должен реализовывать Serializable интерфейс, 
- Поля Entity класс должны быть напрямую доступны только методам самого Entity класса и не должны быть напрямую доступны другим классам, использующим этот Entity. Такие классы должны обращаться только к методам (getter/setter методам или другим методам бизнес-логики в Entity классе),
- Enity класс должен содержать первичный ключ, то есть атрибут или группу атрибутов которые уникально определяют запись этого Enity класса в базе данных,

Допустимые типы атрибутов, входящих в первичный ключ:
- примитивные типы и их обертки Java
- строки
- BigDecimal и BigInteger
- java.util.Date и java.sql.Date 

Встраиваемый (Embeddable) класс это класс который не используется сам по себе, только как часть одного или нескольких Entity классов.

Требования JPA к встраиваемым (Embeddable) классам: 
- Такие классы должны удовлетворять тем же правилам что Entity классы, за исключением того что они не обязаны содержать первичный ключ и быть отмечены аннотацией Entity 
- Embeddable класс должен быть отмечен аннотацией Embeddable или описан в XML файле конфигурации JPA

Mapped Superclass это класс от которого наследуются Entity, он может содержать анотации JPA, однако сам такой класс не является Entity, ему не обязательно выполнять все требования установленные для Entity (например, он может не содержать первичного ключа). Такой класс не может использоваться в операциях EntityManager или Query. Такой класс должен быть отмечен аннотацией MappedSuperclass или соответственно описан в xml файле.

Три типа стратегии наследования мапинга - @Inheritance(strategy=JOINED):
- одна таблица на всю иерархию наследования (a single table per class hierarchy) — все enity, со всеми наследниками записываются в одну таблицу, для идентификации типа entity определяется специальная колонка “discriminator column”
- объединяющая стратегия (joined subclass strategy) — в этой стратегии каждый класс enity сохраняет данные в свою таблицу, но только уникальные колонки (не унаследованные от классов-предков) и первичный ключ, а все унаследованные колонки записываются в таблицы класса-предка, дополнительно устанавливается связь (relationships) между этими таблицами
- одна таблица для каждого класса (table per concrete class strategy) — тут все просто каждый отдельный класс-наследник имеет свою таблицу

У Entity объекта существует четыре статуса жизненного цикла: new, managed, detached, или removed. Их описание 
- new — объект создан, но при этом ещё не имеет сгенерированных первичных ключей и пока ещё не сохранен в базе данных,
- managed — объект создан, управляется JPA, имеет сгенерированные первичные ключи,
- detached — объект был создан, но не управляется (или больше не управляется) JPA,
- removed — объект создан, управляется JPA, но будет удален после commit'a транзакции.

JPA говорит о двух видов кэшей (cache):
- first-level cache (кэш первого уровня) — кэширует данные одной транзакции,
- second-level cache (кэш второго уровня) — кэширует данные дольше чем одна транзакция. Провайдер JPA может, но не обязан реализовывать работу с кэшем второго уровня. Такой вид кэша позволяет сэкономить время доступа и улучшить производительность, однако оборотной стороной является возможность получить устаревшие данные.
