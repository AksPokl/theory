Поиск мусора
Два способа:
Reference counting - у каждого объекта счетчик ссылок. Когда он равен нулю, объект считается мусором. 
Проблема такого подхода в том, что могут быть цикличные ссылки у объектов друг на друга, в то время как они фактически мусор и 
не используются программой.
Tracing - объект считается не мусором, если до него можно добраться с корневых точек 
(GC Root: локальные переменные и параметры методов, java-потоки, статичные переменные, ссылки из JNI.

Организация памяти JVM
Heap - куча. Основной сегмент памяти, где содержатся все объекты и происходит сборка мусора.
Permanent Generation - содержит мета-данные классов.

Heap состоит из
Eden - Сюда аллоцируются объекты. Если нет места запускается GC.
Survivor - точнее их два, S1 и S2, и они меняются ролями. Хранятся объекты, которые признаются живыми во время GC.

Виды сборщиков:

Serial
Parallel
Concurent Mark Sweep (CMS)
Garbage-First (G1)

Serial. Когда нет места в Eden, запускается GC, живые объекты коприруются в S1. 
Вся область Eden очищается. S1 и S2 меняются местами. При последующих циклах в S1 будут записаны живые объекты как из Eden, так и из S2. 
После нескольких циклов обмена S1 и S2 или заполнения области S2, обекты, которые живут достаточно долго перемещаются в Old Greneration.

Для очистки памяти от мусора существуют два основных метода:
Copying collectors
Mark-and-sweep

При copying collectors подходе память делится на две части «from-space» и «to-space», при этом сам принцип работы такой:
Объекты создаются в «from-space»;
Когда «from-space» заполняется, приложение приостанавливается;
Запускается сборщик мусора. Находятся живые объекты в «from-space» и копируются в «to-space»;
Когда все объекты скопированы «from-space» полностью очищается;
«to-space» и «from-space» меняются местами.
