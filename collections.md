ArrayList - "массив", его элементы могут быть доступны непосредственно по индексу. В случае переполнения массива появляется необходимость в новом, имеющем больше места. Размещение и перемещение всех элементов будет занимать O(n) времени. Также, необходимо добавление и удаление элементов для передвижения существующих элементов в массиве. Это, возможно, самое большое неудобство в использовании ArrayList.

Только что созданный объект list, содержит свойства elementData и size.

Итоги
— Быстрый доступ к элементам по индексу за время O(1);
— Доступ к элементам по значению за линейное время O(n);
— Медленный, когда вставляются и удаляются элементы из «середины» списка;
— Позволяет хранить любые значения в том числе и null;
— Не синхронизирован.

LinkedList - это двойной список ссылок на элементы. Таким образом, для доступа к элементу в центре, приходится производить поиск с самого начала и до конца листа. С другой стороны, добавление и удаление элемента в LinkedList быстрее по той причине, что эти операции лишь изменяют сам список. 
O(1) - const
O(n) - линейнo

                 Arraylist	LinkedList
+ get(index)         +  O(1)	O(n)  -
+ add(E)	           -  O(n)	O(1)  +
+ add(E, index)         O(n)	O(n)
+ remove(index)         O(n)	O(n)
+ Iterator.remove()     O(n)	O(1)  +
+ Iterator.add(E)       O(n)	O(1)  +


Iterable -> Collection -> List || Set -> SortedSet ->NavigableSet

Map -> SortedMap -> NavigableMap

Итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.

HashMap

HashMap состоит из «корзин» (bucket). С технической точки зрения «корзины» — это элементы массива, которые хранят ссылки на списки элементов. При добавлении новой пары «ключ-значение», вычисляет хэш-код ключа, на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент. Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, то он заменяется.

Новоявленный объект hashmap, содержит ряд свойств:
table — Массив типа Entry[], который является хранилищем ссылок на списки (цепочки) значений;
loadFactor — Коэффициент загрузки. Значение по умолчанию 0.75 является хорошим компромиссом между временем доступа и объемом хранимых данных;
threshold — Предельное количество элементов, при достижении которого, размер хэш-таблицы увеличивается вдвое. Рассчитывается по формуле (capacity * loadFactor);
size — Количество элементов HashMap-а;

При добавлении элемента, последовательность шагов следующая:
Сначала ключ проверяется на равенство null. Если это проверка вернула true, будет вызван метод putForNullKey(value).

Далее генерируется хэш на основе ключа. Для генерации используется метод hash(hashCode), в который передается key.hashCode().

С помощью метода indexFor(hash, tableLength), определяется позиция в массиве(корзине), куда будет помещен элемент.

Теперь, зная индекс в массиве, мы получаем список (цепочку) элементов, привязанных к этой ячейке. Хэш и ключ нового элемента поочередно сравниваются с хэшами и ключами элементов из списка и, при совпадении этих параметров, значение элемента перезаписывается.

Если же предыдущий шаг не выявил совпадений, будет вызван метод addEntry(hash, key, value, index) для добавления нового элемента.

Когда массив table[] заполняется до предельного значения, его размер увеличивается вдвое и происходит перераспределение элементов.

Итоги

— Добавление элемента выполняется за время O(1), потому как новые элементы вставляются в начало цепочки;
— Операции получения и удаления элемента могут выполняться за время O(1), если хэш-функция равномерно распределяет элементы и отсутствуют коллизии. Среднее же время работы будет Θ(1 + α), где α — коэффициент загрузки. В самом худшем случае, время выполнения может составить Θ(n) (все элементы в одной цепочке);
— Ключи и значения могут быть любых типов, в том числе и null. Для хранения примитивных типов используются соответствующие классы-оберки;
— Не синхронизирован.

TreeMap:
- TreeMap — автоматически сортирует помещённые в неё пары (по возрастанию). Её стоит использовать там, где важен порядок хранения объектов.
- TreeMap гарантирует скорость доступа o(log(n)) для операций containsKey, get, put и remove
- если добавить null как key - NPE
- TreeMap не синхронизирован



HashSet — реализация интерфейса Set, базирующаяся на HashMap. Внутри использует объект HashMap для хранения данных. В качестве ключа используется добавляемый элемент, а в качестве значения — объект-пустышка (new Object()). Из-за особенностей реализации порядок элементов не гарантируется при добавлении.


- Queue<E> FIFO
  - add (throws exception)
  - offer (null)
  - remove (throws exception)
  - poll (null)
  - element return a value (throws an exception)
  - peek return a value (null)
  


  

