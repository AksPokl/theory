ArrayList - "массив", его элементы могут быть доступны непосредственно по индексу. В случае переполнения массива появляется необходимость в новом, имеющем больше места. Размещение и перемещение всех элементов будет занимать O(n) времени. Также, необходимо добавление и удаление элементов для передвижения существующих элементов в массиве. Это, возможно, самое большое неудобство в использовании ArrayList.

LinkedList - это двойной список ссылок на элементы. Таким образом, для доступа к элементу в центре, приходится производить поиск с самого начала и до конца листа. С другой стороны, добавление и удаление элемента в LinkedList быстрее по той причине, что эти операции лишь изменяют сам список. 
O(1) - const
O(n) - линейнo

                 Arraylist	LinkedList
+ get(index)         +  O(1)	O(n)  -
+ add(E)	           -  O(n)	O(1)  +
+ add(E, index)         O(n)	O(n)
+ remove(index)         O(n)	O(n)
+ Iterator.remove()     O(n)	O(1)  +
+ Iterator.add(E)       O(n)	O(1)  +


Iterable -> Collection -> List || Set -> SortedSet ->NavigableSet

Map -> SortedMap -> NavigableMap

Итераторы fail-safe не вызывают никаких исключений при изменении структуры, потому что они работают с клоном коллекции вместо оригинала.

HashMap состоит из «корзин» (bucket). С технической точки зрения «корзины» — это элементы массива, которые хранят ссылки на списки элементов. При добавлении новой пары «ключ-значение», вычисляет хэш-код ключа, на основании которого вычисляется номер корзины (номер ячейки массива), в которую попадет новый элемент. Если корзина пустая, то в нее сохраняется ссылка на вновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный переход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставится ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, то он заменяется.



