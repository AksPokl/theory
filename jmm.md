Модель памяти Java (Java Memory Model, JMM) описывает поведение потоков в среде исполнения Java и какое поведение является законным в многопоточном коде и, как потоки могут взаимодействовать через память. 

Можно выделить несколько основных областей, имеющих отношение к модели памяти:
- Atomicity
На некоторых платформах некоторые операции записи могут оказаться неатомарными.
То есть, пока идёт запись значения одним потоком, другой поток может увидеть какое-то промежуточное состояние. 
Пример: long и double, если они не объявлены как volatile, не обязаны быть атомарными и на многих платформах записываются в две операции: 
старшие и младшие 32 бита отдельно.

- Visibility
Один поток может в какой-то момент временно сохранить значение некоторых полей не в основную память, а в регистры или локальный кэш 
процессора, таким образом второй поток, выполняемый на другом процессоре, читая из основной памяти, может не увидеть последних изменений 
поля. И наоборот, если поток на протяжении какого-то времени работает с регистрами и локальными кэшами, читая данные оттуда, 
он может сразу не увидеть изменений, сделанных другим потоком в основную память.

- Reordering
Для увеличения производительности процессор/компилятор могут переставлять местами некоторые инструкции/операции. 
Вернее, с точки зрения потока, наблюдающего за выполнением операций в другом потоке, операции могут быть выполнены не в том порядке, 
в котором они идут в исходном коде. 
Так же эффект реордеринга может наблюдаться, когда один поток кладет результаты первой операции в регистр или локальный кэш, 
а результат второй операции кладет непосредственно в основную память. Тогда второй поток, обращаясь к основной памяти может 
сначала увидеть результат второй операции, и только потом первой, когда все регистры или кэши синхронизируются с основной памятью.
Еще одна причина reordering, может заключаться в том, что процессор может решить поменять порядок выполнения операций,
если, например, сочтет что такая последовательность выполнится быстрее.

Happend-before
В Java Memory Model введена такая абстракция как happens-before. 
Она обозначает, что если операция X связана отношением happens-before с операцией Y, то весь код следуемый за операцией Y, 
выполняемый в одном потоке, видит все изменения, сделанные другим потоком, до операции X.

Пусть есть поток X и поток Y (не обязательно отличающийся от потока X). И пусть есть операции A (выполняющаяся в потоке X) и B (выполняющаяся в потоке Y).
В таком случае, A happens-before B означает, что все изменения, выполненные потоком X до момента операции A и изменения, которые повлекла эта операция, видны потоку Y в момент выполнения операции B и после выполнения этой операции.

Связь happens-before транзитивна, т.е. если X happens-before Y, а Y happens-before Z, то X happens-before Z. 

Статическая инициализация
Статическая инициализация обладает очень полезным свойством для многопоточных программ: 
все значения, выставленные при объявлении статических полей или в статическом инициализаторе, 
видны любому потоку, получившему доступ к этому классу, без какой либо необходимости в синхронизации. 
JVM гарантирует, что класс будет загружен только одним потоком, после чего все статические поля и становятся доступны для всех 
остальных потоков. Именно за счет этих свойств и работает знаменитый паттерн получения singleton через внутренний статический класс.
