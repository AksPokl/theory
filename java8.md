Лямбда-выражение – это безымянный метод, который служит для передачи поведения из одного места программы в другое так, будто это данные.

Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку ->. 
Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, 
а правая собственно представляет тело лямбда-выражения, где выполняются все действия.

Тип не указывается - компилятор javac выводит тип переменной из контекста (пример, из сигнатуры метода)

Доступ к переменным внешней области действия из лямбда-выражения:

- неизменяемые (effectively final - не обязательно помеченные как final) локальные переменные (тк локальные переменные
находятся в стеке и поток, в котором использовалось лямбда выражение, может получить доступ к локальной переменной - лямбда-выражение будет обращаться к копии переменной, а тк переменная final то не имеет значения, если обращение к копии);
- поля класса;
- статические переменные.

К методам по умолчанию реализуемого функционального интерфейса обращаться внутри лямбда-выражения запрещено.

Типы ссылок:
- на статический метод;
- на метод экземпляра;
- на конструктор.

Запись в переменную в пределах лямбда-выражения также запрещена.

Внутри лямбда-выражений запрещено обращаться к методам по умолчанию.

Опциональные значения (optionals) не являются функциональными интерфейсами, однако являются удобным средством предотвращения 
NullPointerException.

Опциональные значение — это по сути контейнер для значения, которое может быть равно null. 
Например, вам нужен метод, который возвращает какое-то значение, но иногда он должен возвращать пустое значение. 
Вместо того, чтобы возвращать null, в Java 8 вы можете вернуть опциональное значение.

Операции над потоками бывают или промежуточными (intermediate) или конечными (terminal). 
Конечные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же поток.

Стримы создаются на основе источников каких-либо, например классов из java.util.Collection.

Ассоциативные массивы (maps), например HashMap, не поддерживаются.

Stream – аналог Iterator, только с внутренним итерированием.

конечные методы:
findFirst() возвращает первый элемент;
findAny() возвращает любой подходящий элемент;
collect() представление результатов в виде коллекций и других структур данных;
count() возвращает количество элементов;
anyMatch() возвращает true, если условие выполняется хотя бы для одного элемента;
noneMatch() возвращает true, если условие не выполняется ни для одного элемента;
allMatch() возвращает true, если условие выполняется для всех элементов;
min() возвращает минимальный элемент, используя в качестве условия Comparator;
max() возвращает максимальный элемент, используя в качестве условия Comparator;
forEach() применяет функцию к каждому объекту (порядок при параллельном выполнении не гарантируется);
forEachOrdered() применяет функцию к каждому объекту с сохранением порядка элементов;
toArray() возвращает массив значений;
reduce()позволяет выполнять агрегатные функции и возвращать один результат.
Для числовых стримов дополнительно доступны:
sum() возвращает сумму всех чисел;
average() возвращает среднее арифметическое всех чисел.


промежуточные методы:
filter() отфильтровывает записи, возвращая только записи, соответствующие условию;
skip() позволяет пропустить определённое количество элементов в начале;
distinct() возвращает стрим без дубликатов (для метода equals());
map() преобразует каждый элемент;
peek() возвращает тот же стрим, применяя к каждому элементу функцию;
limit() позволяет ограничить выборку определенным количеством первых элементов;
sorted() позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator;
mapToInt(), mapToDouble(), mapToLong() - аналоги map() возвращающие стрим числовых примитивов;
flatMap(), flatMapToInt(), flatMapToDouble(), flatMapToLong() - похожи на map(), но могут создавать из одного элемента несколько.


reduce()

BinaryOperator<Integer> accumulator = (acc, element) -> acc + element; 
int sum = accumulator.apply(
accumulator.apply( 
  accumulator.apply(0, 1),
2), 3);
  ==
int sum = Stream.of(1, 2, 3).reduce(0, (acc, element) -> acc + element);
  
flatMap() 
принимает лямбда-выражение известное как функция (Function), которое "разворачивает" Stream-ы в один.

findFirst()
вернет Optional<T>, хранящий строго первый элемент потока. 

findAny()
Возвращает Optional<T>, хранящий некоторый элемент стрима, или пустой Optional<T>, если стрим пуст. Поведение этой операции не определено - он может выбрать любой элемент в потоке. Это позволяет обеспечить максимальную производительность при параллельных операциях;Т.е., при непараллельном стриме он вернет первый элемент. А при параллельном стриме он может вернуть любой элемент.


Default methods inheritance:
1) Если интерфейс Б наследует интерфейс А, и класс С имплементит А -> A default
2) Если интерфейс Б наследует интерфейс А, и класс С имплементит Б -> Б default
3) Если интерфейс Б наследует интерфейс А, и класс С имплементит А и Б -> Б default
4) Если интерфейс Б наследует интерфейс А, и класс С override default  -> Предпочтение отдается конкретному методу, а не методу по умолчанию
4) Если в интерфейсе А и Б есть одинаковые default-методы и класс С implements оба -> compilation error


Статические методы интерфейса похожи на методы по умолчанию, за исключением того, что для них отсутствует возможность переопределения в классах, реализующих интерфейс.
