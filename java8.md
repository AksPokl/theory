Основу лямбда-выражения составляет лямбда-оператор, который представляет стрелку ->. 
Этот оператор разделяет лямбда-выражение на две части: левая часть содержит список параметров выражения, 
а правая собственно представляет тело лямбда-выражения, где выполняются все действия.

Доступ к переменным внешней области действия из лямбда-выражения:

- неизменяемые (effectively final - не обязательно помеченные как final) локальные переменные;
- поля класса;
- статические переменные.

Тиаы ссылок:
- на статический метод;
- на метод экземпляра;
- на конструктор.

Запись в переменную в пределах лямбда-выражения также запрещена.

Внутри лямбда-выражений запрещено обращаться к методам по умолчанию.

Опциональные значения (optionals) не являются функциональными интерфейсами, однако являются удобным средством предотвращения 
NullPointerException.

Опциональные значение — это по сути контейнер для значения, которое может быть равно null. 
Например, вам нужен метод, который возвращает какое-то значение, но иногда он должен возвращать пустое значение. 
Вместо того, чтобы возвращать null, в Java 8 вы можете вернуть опциональное значение.

Операции над потоками бывают или промежуточными (intermediate) или конечными (terminal). 
Конечные операции возвращают результат определенного типа, а промежуточные операции возвращают тот же поток.

Стримы создаются на основе источников каких-либо, например классов из java.util.Collection.

Ассоциативные массивы (maps), например HashMap, не поддерживаются.

конечные методы:
findFirst() возвращает первый элемент;
findAny() возвращает любой подходящий элемент;
collect() представление результатов в виде коллекций и других структур данных;
count() возвращает количество элементов;
anyMatch() возвращает true, если условие выполняется хотя бы для одного элемента;
noneMatch() возвращает true, если условие не выполняется ни для одного элемента;
allMatch() возвращает true, если условие выполняется для всех элементов;
min() возвращает минимальный элемент, используя в качестве условия Comparator;
max() возвращает максимальный элемент, используя в качестве условия Comparator;
forEach() применяет функцию к каждому объекту (порядок при параллельном выполнении не гарантируется);
forEachOrdered() применяет функцию к каждому объекту с сохранением порядка элементов;
toArray() возвращает массив значений;
reduce()позволяет выполнять агрегатные функции и возвращать один результат.
Для числовых стримов дополнительно доступны:
sum() возвращает сумму всех чисел;
average() возвращает среднее арифметическое всех чисел.


промежуточные методы:
filter() отфильтровывает записи, возвращая только записи, соответствующие условию;
skip() позволяет пропустить определённое количество элементов в начале;
distinct() возвращает стрим без дубликатов (для метода equals());
map() преобразует каждый элемент;
peek() возвращает тот же стрим, применяя к каждому элементу функцию;
limit() позволяет ограничить выборку определенным количеством первых элементов;
sorted() позволяет сортировать значения либо в натуральном порядке, либо задавая Comparator;
mapToInt(), mapToDouble(), mapToLong() - аналоги map() возвращающие стрим числовых примитивов;
flatMap(), flatMapToInt(), flatMapToDouble(), flatMapToLong() - похожи на map(), но могут создавать из одного элемента несколько.

Какие различия между findFirst и findAny в Java 8?

findAny() Возвращает Optional<T>, хранящий некоторый элемент стрима, или пустой Optional<T>, если стрим пуст. Поведение этой операции не определено - он может выбрать любой элемент в потоке. Это позволяет обеспечить максимальную производительность при параллельных операциях; Т.е., при непараллельном стриме он вернет первый элемент. А при параллельном стриме он может вернуть любой элемент.

findFirst() вернет Optional<T>, хранящий строго первый элемент потока.


